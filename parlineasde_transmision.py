# -*- coding: utf-8 -*-
"""ParLineasde Transmision.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y2UiFlsuSSndFnn8UY1C9iUBotHzZXAk
"""

import numpy as np 
import matplotlib.pyplot as plt 

V =  5#@param {type: "number"}
f = 800e6 #@param {type: "number"}
Zs =  2#@param {type: "number"}
er = 2.2 #@param {type: "number"}
ZC = 50 #@param {type: "number"}
Zcar = 75
longitud =  10#@param {type: "number"}
alfa = 0.001 #@param {type: "number"}
c = 3e8 #VElociadad de la luz
cantidad_ondas =  50#@param {type: "number"}

ReflexCarga = (ZC-Zcar)/(ZC+Zcar)
omega = 2*np.pi*f
beta = (omega*np.sqrt(er))/(c)
gamma = complex(alfa,beta)
ReflexFuente = ReflexCarga*np.exp(2*gamma*(-longitud-0)) 


z = np.arange(-longitud,0,longitud/100)
ZFuente = Zcar*((1+ReflexFuente)/(1-ReflexFuente)) 
VFuente = (V*ZFuente)/(ZFuente+Zs) 
Vincidente = VFuente/(np.exp(-gamma*-longitud)*(1+ReflexFuente))
SeñalIncidente = Vincidente*np.exp(-alfa*z)*np.cos(-beta*z)


VReflex = ((ReflexFuente)*Vincidente)/(np.exp(2*gamma*(-longitud)))
Señalreflejado = VReflex*np.exp(alfa*z)*np.cos(beta*z)
VCarga = Vincidente*(1+ReflexCarga)
potCarga = 0.5*np.real(((np.abs(VCarga))**2)/ZC)

Crz = ReflexCarga*np.exp(2*gamma*z)
Zz = Zcar*((1+Crz)/(1-Crz))
Vz = Vincidente*np.exp(-gamma*z)*(1+Crz)
Iz = Vz/Zz
PPf = .5*np.real((np.abs(Vz)**2)/Zz)

plt.figure(figsize=(12,6))
plt.plot(z,PPf, label= "PotenciaPromedio", c='r')
plt.title("potencia Promedio ")
plt.xlabel("Distancia (m)")
plt.ylabel("$P(z)$")
plt.legend()
plt.show()


fig, ax = plt.subplots(2,1, figsize=(12,12))
ax[0].plot(z, np.abs(Crz), label='Coeficiente Reflexion', c='g')
ax[0].set_title("Coeficiente de reflexión")
ax[0].set_xlabel("distancia (m)")
ax[0].set_ylabel("valor Coeficiente")
ax[1].plot(z, np.angle(Crz),label='fase', c='b')
ax[1].set_title("fase")
ax[1].set_xlabel("distancia (m)")
ax[1].set_ylabel("valor ángulo(rad)")
plt.show()

fig, ax = plt.subplots(2,1, figsize=(12,12))
ax[0].plot(z, np.abs(Vz), label='Voltaje', c='c')
ax[0].set_title("Voltaje", fontsize='xx-large')
ax[0].grid(True, linestyle='-.', color='.3')
ax[0].set_xlabel("distancia (m)")
ax[0].set_ylabel("Voltaje (V)")
ax[1].plot(z, np.angle(Vz),label='fase', c='m')
ax[1].set_title("fase")
ax[1].set_xlabel("distancia (m)")
ax[1].set_ylabel("valor ángulo(rad)")
ax[1].grid(True, linestyle='-.', color='.3')
plt.show()


fig, ax = plt.subplots(2,1, figsize=(12,12))
ax[0].plot(z, np.abs(Zz), label='Voltaje', c='k')
ax[0].set_title("impedancia")
ax[0].set_xlabel("distancia (m)")
ax[0].set_ylabel("$impedancia (\Omega)$")
ax[1].plot(z, np.angle(Zz),label='fase')
ax[1].set_title("fase")
ax[1].set_xlabel("distancia (m)")
ax[1].set_ylabel("valor ángulo(rad)")
plt.show()


ondas = np.linspace(-longitud, 0, cantidad_ondas)
plt.figure(figsize=(12,6))
plt.title("onda estacionaria")
plt.xlabel("distancia (m)")
plt.ylabel("amplitud (V)")
for t in ondas:
    ondaEstacionaria = Vincidente*np.exp(-alfa*z)*np.cos(omega*t - beta*z) + VReflex*np.exp(alfa*z)*np.cos(omega*t + beta*z) 
    plt.plot(z,np.real(ondaEstacionaria), 'y')


plt.show()

ROET = (1+ReflexCarga)/(1-ReflexCarga)
PotReflex = (np.abs(ReflexCarga)**2)*100*potCarga
PotTrans = (1-(np.abs(ReflexCarga)**2))*potCarga*100

print("Coeficiente de reflexión en la carga: ", ReflexCarga)
print("ROET: ", ROET)
print("potencia reflejada en la carga: ", PotReflex)
print("potencia transferida a la carga: ",PotTrans)