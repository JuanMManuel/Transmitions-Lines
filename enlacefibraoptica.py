# -*- coding: utf-8 -*-
"""EnlaceFibraOptica.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KshJ0jyy0VtIJBWx9dLh1S-l-sl918mq
"""

#%matplotlib qt
import numpy as np
import matplotlib.pyplot as plt

# Valores del transmisor:
bps = 2.5e9 # tasa de bits
potTx = 28 # potencia en dBm
Tb = 1/bps 
lamda = 1550e-9 # longitud de onda
c = 3e8 # velocidad de propagación
chirp = "-3" #@param [-3, 0, 0.7] {allow-input: true}
chirp= float(chirp)
alfaEstandar = 0.0006 # atenuación fibra estandar

#amplificador:
potAmplificador = 28 # dBm
senAmplificador = -18 # sensibilidad del amplificador en dBm 
# valores fibra compensadora:
DCompensadora = (-110*1e-12)/(1e-9*1e3) # parámetro de Dispersión de la fibra compensadora 
alfaCompensadora = 0.35/1e3
distancia = 3287000 # distancia entre Lima y Santiago
DEstandar = (17*1e-12)/(1e-9*1e3) # 
beta2Estandar = (-1*(lamda**2)*DEstandar)/(2*np.pi*c)
beta2Compensadora = (-1*(lamda**2)*DCompensadora)/(2*np.pi*c)

To = Tb/4 
Tz = Tb/2
j1 = beta2Estandar/(To**2)
j2 = Tz/To
A = (chirp*j1)**2 +(j1)**2
B = 2*chirp*j1
C = 1-(j2)**2
z1 = (-B+np.sqrt(B**2-4*A*C))/(2*A)
z2 = (-B-np.sqrt(B**2-4*A*C))/(2*A)
j22 = To/Tz
j21 = beta2Compensadora/(Tz**2)
A2 = (chirp*j21)**2 + (j21)**2
B2 = 2*chirp*j21
C2 = 1-(j22)**2
z11 = (-B2+np.sqrt(B2**2-4*A2*C2))/(2*A2)
z22 = (-B2-np.sqrt(B2**2-4*A2*C2))/(2*A2)

#calculamos el ensanchamiento del pulso
Ldf = (To**2)/(np.abs(beta2Estandar))
Ldfd = (Tz**2)/(np.abs(beta2Compensadora))
# calculamos la cantidad de tramos de fibra estandar
numTramos = distancia/z1

# el siguiente paso es elaborar el presupuesto de potencia
z1n = 60000
z11n = (potAmplificador -senAmplificador-alfaEstandar*(60000))/alfaCompensadora
uno = potAmplificador -z1n*alfaEstandar-z11n*alfaCompensadora
dos = senAmplificador

# graficación de los resultados

z = np.linspace(0,80000,100)
z1 = np.linspace(0,12000,100)
T1 = (np.sqrt((1+(chirp*beta2Estandar*z)/(To**2))**2+(beta2Estandar*z)/To**2))*To
T2 = (np.sqrt((1+(chirp*beta2Compensadora*z1)/(To**2))**2+(beta2Compensadora*z1)/To**2))*To

# grafica de ancho de pulso 
fig, (ax1,ax2) = plt.subplots(2,1,figsize = (12,6))
#pulso en la fibra estandar
ax1.plot(z,T1,'g',label='pulso FibraEstandar')
ax1.legend()
ax1.grid()
ax1.set_title('Fibra Estandar')
#pulso fibra compensadora
ax2.plot(z1, T2, 'b', label= 'pulso Fibra compensadora')
ax2.set_xlabel('distancia (km)')
ax2.grid()
ax2.legend()
ax2.set_title('fibra compensadora')
fig.suptitle('ancho de pulso', fontsize=16)
fig.show()

z = np.linspace(0,70000,100)
z1 = np.linspace(0,30000,100)
potTxW = (10**(potTx/10))/1000
pd = potTx**(-alfaEstandar*z)
pc = potTx**(-alfaCompensadora*z1)
pote = potTx-alfaEstandar*z
potc = potTx-alfaCompensadora*z1
poten = 10**(pote/10)
potcn = 10**(potc/10)

# gráfica para la potencia

fig, (ax1,ax2) = plt.subplots(1,2,figsize=(12,6))
#fibra estandar
ax1.plot(z,poten, 'r', label = 'Fibra Estandar')
ax1.set_xlabel('distancia (Km)')
ax1.set_ylabel('potencia (dBm)')
ax1.grid()
ax1.legend()
ax1.set_title('Fibra Estandar')
#fibra compensadora
ax2.plot(z1,potcn, label = 'Fibra Compensadora')
ax2.grid()
ax2.legend()
ax2.set_title('Fibra Compensadora')
ax2.set_xlabel("distancia m")
fig.suptitle('Potencia en La Fibra', fontsize=16)
plt.show()

# gráfica del pulso en el tiempo
t = np.linspace(-5e-10,5e-10,1000)
CCe = chirp + (1 + chirp**2)* beta2Estandar*t/To**2
CCc = CCe +(1+CCe**2)*beta2Compensadora*t/To**2


pul = np.exp(-0.5*((t/To)**2))*(np.cos(-0.5*chirp*((t/To)**2))-1j*np.sin(-0.5*chirp*((t/To)**2)))
pull = np.exp(-0.5*((t/Tz)**2))*(np.cos(-0.5*CCe*((t/Tz)**2))-1j*np.sin(-0.5*CCe*((t/Tz)**2)))
pulll = np.exp(-0.5*((t/Tz)**2))*(np.cos(-0.5*CCc*((t/Tz)**2))-1j*np.sin(-0.5*CCc*((t/Tz)**2)))

fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(18,6))
ax1.plot(t,np.abs(pul),'b', label='pulso')
ax1.set_xlabel('tiempo')
ax1.set_ylabel('magitud')
ax1.legend()
ax1.grid()
ax1.set_title('pulso a la entrada de la fibra')
ax2.plot(t,np.abs(pull), 'g', label= 'salida')
ax2.set_xlabel('tiempo')
ax2.legend()
ax2.set_title('pulso a la salida de la fibra')
ax2.grid()
ax3.plot(t,np.abs(pulll),'r', label= 'salida a la fibra compensadora')
ax3.set_xlabel('tiempo')
ax3.legend()
ax3.grid()
ax3.set_title('salida de la fibra compensadora')
fig.suptitle('comportamiento del pulso')
fig.show()
z1 = (-B+np.sqrt(B**2-4*A*C))/(2*A)
z2 = (-B-np.sqrt(B**2-4*A*C))/(2*A)

"""##SOLUCIÓN PREGUNTAS.
1.elección del chirp 

$\Rightarrow $ El chirp elegido es el de -3 porque es el que repara el ensanchamiento producido por la fibra estandar  

2. 



"""

print("para in chirp de {0}, tenemos los siguientes datos: ".format(chirp))
print("Longitud de la fibra Estandar")
print("{:.2f} metros ".format(z1))
print("distancia por dispersión en la fibra Estandar:")
print('{:.0f} m \n'.format(Ldf))

print('la cantidad de tramos necesarios son: {}'.format(int(numTramos+0.5)))

print('Longitud de fibra óptica compensadora: {:.1f} m'.format(z11))
print('Máxima longitud de fibra compesadora: {:.0f} m'.format(z11))
print('Longitud de Dispersión de fibra compensadora: {:.0f} m \n'.format(Ldfd))

print('las distancias máximas de las fibras teniendo en cuenta el presupuesto de enlace son:')
print('fibra compensadora:{:.0f} m'.format(z11n))
print('fibra estandar: {:}'.format(z1n))