# -*- coding: utf-8 -*-
"""ParametrosLineaTx.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HTof4NWSJnEJ0pQjPovcMFSmHTbDVsTk
"""

#%matplotlib qt

import numpy as np #importación de libreria numpy
import matplotlib.pyplot as plt #importación de libreria matplotlib

# Datos de entrada

Vf =  5#@param {type: "number"}
f = 800e6 #@param {type: "number"}
Zf =  2#@param {type: "number"}
er = 2.2 #@param {type: "number"}
ZL = 50 #@param {type: "number"}
Zo = 75
longitud =  10#@param {type: "number"}
alfa = 0.001 #@param {type: "number"}
c = 3e8 
numOndas =  50#@param {type: "number"}

CrCarga = (ZL-Zo)/(ZL+Zo) # hallamos el coeficiente de reflexión en la carga
#ahora vamos a buscarlo en el transmisor
omega = 2*np.pi*f # frecuencia angular
beta = (omega*np.sqrt(er))/(c) # constante de fase
gamma = complex(alfa,beta) # constante de propagación
CrFuente = CrCarga*np.exp(2*gamma*(-longitud-0)) # coeficiente de reflexión en la fuente

#luego podemos hallar la señal de voltaje incidente
z = np.arange(-longitud,0,longitud/100)# eje z de espacio
ZFuente = Zo*((1+CrFuente)/(1-CrFuente)) # impedancia en la fuente 
VFuente = (Vf*ZFuente)/(ZFuente+Zf) # voltaje en la fuente
VoMas = VFuente/(np.exp(-gamma*-longitud)*(1+CrFuente)) # voltaje incidente
VIncidente = VoMas*np.exp(-alfa*z)*np.cos(-beta*z) # señal de voltaje incidente

#señal reflejada
VoMenos = ((CrFuente)*VoMas)/(np.exp(2*gamma*(-longitud)))
Vreflejado = VoMenos*np.exp(alfa*z)*np.cos(beta*z) # señal de voltaje reflejado 
VCarga = V_carga = VoMas*(1+CrCarga)
potCarga = 0.5*np.real(((np.abs(VCarga))**2)/ZL)
# valores dependientes del espacio
Cr_z = CrCarga*np.exp(2*gamma*z)
Z_z = Zo*((1+Cr_z)/(1-Cr_z))
V_z = VoMas*np.exp(-gamma*z)*(1+Cr_z)
I_z = V_z/Z_z
Pav_z = .5*np.real((np.abs(V_z)**2)/Z_z) # potencia promedio en la fuente

#GRÁFICA DE LOS VALORES
#Gráfica de la potencia
plt.figure(figsize=(12,6))
plt.plot(z,Pav_z, label= "potPromedio", lw=3, c='r')
plt.title("potencia Promedio ", fontsize='xx-large')
plt.xlabel("Distancia (m)", fontsize='xx-large')
plt.ylabel("$P(z)$", fontsize='xx-large')
plt.grid(True, linestyle='-.', color='.3')
plt.legend()
plt.show()

#grafica de coeficiente de reflexión
fig, ax = plt.subplots(2,1, figsize=(12,12))
ax[0].plot(z, np.abs(Cr_z), label='coefReflexion', c='g', lw=3)
ax[0].set_title("Coeficiente de reflexión", fontsize='xx-large')
ax[0].grid(True, linestyle='-.', color='.3')
ax[0].set_xlabel("distancia (m)", fontsize='x-large')
ax[0].set_ylabel("valor Coeficiente", fontsize='x-large')
ax[1].plot(z, np.angle(Cr_z),label='fase', c='b', lw=3)
ax[1].set_title("fase", fontsize='xx-large')
ax[1].set_xlabel("distancia (m)", fontsize='x-large')
ax[1].set_ylabel("valor ángulo(rad)", fontsize='x-large')
ax[1].grid(True, linestyle='-.', color='.3')
plt.show()

#grafica del Voltaje
fig, ax = plt.subplots(2,1, figsize=(12,12))
ax[0].plot(z, np.abs(V_z), label='Voltaje', c='#F92600', lw=3)
ax[0].set_title("Voltaje", fontsize='xx-large')
ax[0].grid(True, linestyle='-.', color='.3')
ax[0].set_xlabel("distancia (m)", fontsize='x-large')
ax[0].set_ylabel("Voltaje (V)", fontsize='x-large')
ax[1].plot(z, np.angle(V_z),label='fase', c='#6B00C4', lw=3)
ax[1].set_title("fase", fontsize='xx-large')
ax[1].set_xlabel("distancia (m)", fontsize='x-large')
ax[1].set_ylabel("valor ángulo(rad)", fontsize='x-large')
ax[1].grid(True, linestyle='-.', color='.3')
plt.show()

#grafica del Voltaje
fig, ax = plt.subplots(2,1, figsize=(12,12))
ax[0].plot(z, np.abs(Z_z), label='Voltaje', c='#F92600', lw=3)
ax[0].set_title("impedancia", fontsize='xx-large')
ax[0].grid(True, linestyle='-.', color='.3')
ax[0].set_xlabel("distancia (m)", fontsize='x-large')
ax[0].set_ylabel("$impedancia (\Omega)$", fontsize='x-large')
ax[1].plot(z, np.angle(Z_z),label='fase', c='#6B00C4', lw=3)
ax[1].set_title("fase", fontsize='xx-large')
ax[1].set_xlabel("distancia (m)", fontsize='x-large')
ax[1].set_ylabel("valor ángulo(rad)", fontsize='x-large')
ax[1].grid(True, linestyle='-.', color='.3')
plt.show()

#gráfica de la onda estacionaria
ondas = np.linspace(-longitud, 0, numOndas)
plt.figure(figsize=(12,6))
plt.title("onda estacionaria")
plt.xlabel("distancia (m)")
plt.ylabel("amplitud (V)")
for t in ondas:
    ondaEstacionaria = VoMas*np.exp(-alfa*z)*np.cos(omega*t - beta*z) + VoMenos*np.exp(alfa*z)*np.cos(omega*t + beta*z) 
    plt.plot(z,np.real(ondaEstacionaria), 'b')


plt.show()

ROET = (1+CrCarga)/(1-CrCarga)
PotReflejada = (np.abs(CrCarga)**2)*100*potCarga
potTransferida = (1-(np.abs(CrCarga)**2))*potCarga*100

print("Coeficiente de reflexión en la carga: ", CrCarga)
print("ROET: ", ROET)
print("potencia reflejada en la carga: ", PotReflejada)
print("potencia transferida a la carga: ",potTransferida)
print("impedancia de la fuente", ZFuente)
print("potencia en la carga", potCarga)
print("voltaje máximo: ", VoMas)
print("voltaje mínimo: ", VoMenos)