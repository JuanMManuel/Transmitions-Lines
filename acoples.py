# -*- coding: utf-8 -*-
"""acoples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zaN-dz2cA-nhP1b0V2iYN4PzjrZcJ2Ob
"""

import numpy as np
import matplotlib.pyplot as plt
ZL_real =  0.577#@param {type: "number"}
ZL_imag =  -0.385#@param {type: "number"}
Z0 =  1#@param {type:"number"}
longitud_de_onda =  16#@param {type: "number"}

#Realiza la transformación bilineal de Moebius normalizada
#Gamma = (z-1)/(z+1)

    
def TBM(x,y):
    x = np.array(x)
    y = np.array(y)
    Zn = (x + y*1j)
    CR = (Zn-1)/(Zn+1)
    CRx = np.real(CR)
    CRy = np.imag(CR)
    return CRx, CRy

x,y = TBM([1], [2 ])

#Realiza la transformación bilineal de Moebius normalizada inversa
#z = (1 + Gamma)/(1 - Gamma)
def ITBM(xT,yT):
    xT = np.array(xT) 
    yT = np.array(yT)
    T = xT + yT*1j
    z = (1+T)/(1-T)
    x = np.real(z)
    y = np.imag(z)
    return x, y

Lm = 200
step = 0.1

#Eje Y
y=np.arange(-Lm-step, Lm+step, step)
x = y*0
xT1, yT1 = TBM(x, y)

#Eje X
x= np.arange(0,Lm+step,step)
y =x*0
xT0,yT0=TBM(x, y)

#x=1
y= np.arange(-Lm-step,Lm+step,step)
x= y*0+1
xT2,yT2=TBM(x, y)

#y=1
x=np.arange(0,Lm+step,step)
y =x*0+1
xT3,yT3 =TBM(x, y)

#y=-1
x=np.arange(0,Lm+step,step)
y = x*0-1
xT4,yT4 = TBM(x, y)

#Transformar un punto
z0=Z0
xp,yp=TBM(ZL_real/z0,ZL_imag/z0)
T= xp + yp*1j
M=np.abs(T) #magnitud
A = np.angle(T) #ángulo

#Añadir círculo
La = M
cir = plt.Circle((0,0), La, ls='--', fill= False)

#Desplazamiento hacia la carga
longitud =2
lambd=longitud_de_onda
delta = (np.arccos(M) - A)/(4*np.pi) #Lo necesito para el acople
Tdesplazado = T*np.exp(2*1j*2*np.pi*(delta))
xpTd= np.real(Tdesplazado)
ypTd= np.imag(Tdesplazado)

#Lectura de la Impedancia
x,y = ITBM(xpTd, ypTd)

fig, ax= plt.subplots(figsize =(8,8))
ax.plot(xT0, yT0, 'b')
ax.plot(xT1, yT1, 'b')
ax.plot(xT2, yT2, 'b')
ax.plot(xT3, yT3, 'b')
ax.plot(xT4, yT4, 'b')
ax.plot(xp,yp, 'r*')
ax.plot(xpTd,ypTd, 'r*')
ax.set_axis_off()
ax.add_artist(cir)

#Calcular el l/lambda
A= np.angle(T)
if A <= np.pi:
  lN= (np.pi-A)*0.5/2*np.pi
else:
  lN= (2*np.pi-A+np.pi)*0.5/(2*np.pi)
print("El coeficiente de reglexion es",A)
print("La magnitud es",M)
print("La posicion del punto desplzadado es",Tdesplazado)
print("l/lambda es: ", lN)

import numpy as np
import matplotlib.pyplot as plt

Desplazamiento =  0.125#@param {type: "number"}
ZL_real =  0.577#@param {type: "number"}
ZL_imag =  -0.385#@param {type: "number"}
Z0 =  1#@param {type:"number"}
longitud_de_onda =  16#@param {type: "number"}

#Realiza la transformación bilineal de Moebius normalizada
#Gamma = (z-1)/(z+1)
def TBM(x,y):
    x = np.array(x)
    y = np.array(y)
    Zn = x + y*1j
    CR = (Zn-1)/(Zn+1)
    CRx = np.real(CR)
    CRy = np.imag(CR)
    return CRx, CRy

x,y = TBM([1], [2 ])

#Realiza la transformación bilineal de Moebius normalizada inversa
#z = (1 + Gamma)/(1 - Gamma)
def ITBM(xT,yT):
    xT = np.array(xT) 
    yT = np.array(yT)
    T = xT + yT*1j
    z = (1+T)/(1-T)
    x = np.real(z)
    y = np.imag(z)
    return x, y

Lm = 200
step = 0.1

#Eje Y
y=np.arange(-Lm-step, Lm+step, step)
x = y*0
xT1, yT1 = TBM(x, y)

#Eje X
x= np.arange(0,Lm+step,step)
y =x*0
xT0,yT0=TBM(x, y)

#x=1
y= np.arange(-Lm-step,Lm+step,step)
x= y*0+1
xT2,yT2=TBM(x, y)

#y=1
x=np.arange(0,Lm+step,step)
y =x*0+1
xT3,yT3 =TBM(x, y)

#y=-1
x=np.arange(0,Lm+step,step)
y = x*0-1
xT4,yT4 = TBM(x, y)

#Transformar un punto
z0=Z0
xp,yp=TBM(ZL_real/z0,ZL_imag/z0)
T= xp + yp*1j
M=np.abs(T) #magnitud
A = np.angle(T) #ángulo

#Añadir círculo
La = M
cir = plt.Circle((0,0), La, ls='--', fill= False)

#Desplazamiento hacia la carga
longitud =2
lambd=longitud_de_onda
delta = Desplazamiento
Tdesplazado = T*np.exp(2*1j*2*np.pi*(delta))
xpTd= np.real(Tdesplazado)
ypTd= np.imag(Tdesplazado)

#Lectura de la Impedancia
x,y = ITBM(xpTd, ypTd)

fig, ax= plt.subplots(figsize =(8,8))
ax.plot(xT0, yT0, 'b')
ax.plot(xT1, yT1, 'b')
ax.plot(xT2, yT2, 'b')
ax.plot(xT3, yT3, 'b')
ax.plot(xT4, yT4, 'b')
ax.plot(xp,yp, 'r*')
ax.plot(xpTd,ypTd, 'r*')
ax.set_axis_off()
ax.add_artist(cir)

#Calcular el l/lambda
A= np.angle(T)
if A <= np.pi:
  lN= (np.pi-A)*0.5/2*np.pi
else:
  lN= (2*np.pi-A+np.pi)*0.5/(2*np.pi)
print("El coeficiente de reglexion es",A)
print("La magnitud es",M)
print("La posicion del punto desplzadado es",Tdesplazado)
print("l/lambda es: ", lN)

import numpy as np
import matplotlib.pyplot as plt
ZL_real =  0.577#@param {type: "number"}
ZL_imag =  -0.385#@param {type: "number"}
Z0 =  8#@param {type:"number"}
longitud_de_onda =  2#@param {type: "number"}

#Realiza la transformación bilineal de Moebius normalizada
#Gamma = (z-1)/(z+1)

Zl = ZL_real +ZL_imag*1j
def TBM(x,y):
    x = np.array(x)
    y = np.array(y)
    Zn = (x + y*1j)
    CR = (Zn-1)/(Zn+1)
    CRx = np.real(CR)
    CRy = np.imag(CR)
    return CRx, CRy

x,y = TBM([1], [2 ])

#Realiza la transformación bilineal de Moebius normalizada inversa
#z = (1 + Gamma)/(1 - Gamma)
def ITBM(xT,yT):
    xT = np.array(xT) 
    yT = np.array(yT)
    T = xT + yT*1j
    z = (1+T)/(1-T)
    x = np.real(z)
    y = np.imag(z)
    return x, y

Lm = 200
step = 0.1
Yl = 1/Zl
Y0 = 1/Z0
yL= Yl/Y0

#Eje Y
y=np.arange(-Lm-step, Lm+step, step)
x = y*0
xT1, yT1 = TBM(x, y)

#Eje X
x= np.arange(0,Lm+step,step)
y =x*0
xT0,yT0=TBM(x, y)

#x=1
y= np.arange(-Lm-step,Lm+step,step)
x= y*0+1
xT2,yT2=TBM(x, y)

#y=1
x=np.arange(0,Lm+step,step)
y =x*0+1
xT3,yT3 =TBM(x, y)

#y=-1
x=np.arange(0,Lm+step,step)
y = x*0-1
xT4,yT4 = TBM(x, y)

#Transformar un punto
z0=Z0
xp,yp=TBM(ZL_real/z0,ZL_imag/z0)
T= xp + yp*1j
M=np.abs(T) #magnitud
A = np.angle(T) #ángulo

#Añadir círculo
La = M
cir = plt.Circle((0,0), La, ls='--', fill= False)

#Desplazamiento hacia la carga
longitud =2
lambd=longitud_de_onda
delta = (np.arccos(M) - A)/(4*np.pi) #Lo necesito para el acople
Tdesplazado = T*np.exp(2*1j*2*np.pi*(delta))
xpTd= np.real(Tdesplazado)
ypTd= np.imag(Tdesplazado)
yE= -ZL_imag*1j * lambd
la= yE

#Lectura de la Impedancia
x,y = ITBM(xpTd, ypTd)

fig, ax= plt.subplots(figsize =(8,8))
ax.plot(xT0, yT0, 'b')
ax.plot(xT1, yT1, 'b')
ax.plot(xT2, yT2, 'b')
ax.plot(xT3, yT3, 'b')
ax.plot(xT4, yT4, 'b')
ax.plot(xp,yp, 'r*')
ax.plot(xpTd,ypTd, 'r*')
ax.set_axis_off()
ax.add_artist(cir)

#Calcular el l/lambda
A= np.angle(T)
if A <= np.pi:
  lN= (np.pi-A)*0.5/2*np.pi
else:
  lN= (2*np.pi-A+np.pi)*0.5/(2*np.pi)
print("la longitud para ZL es: ", delta)
print("La longitud para Z0 es: ", la)